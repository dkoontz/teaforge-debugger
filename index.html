<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; connect-src 'self' ws: wss:;">
    <title>TeaForge Debugger</title>
    <link rel="stylesheet" href="node_modules/@fortawesome/fontawesome-free/css/all.min.css">
    <link rel="stylesheet" href="dist/styles.css">
</head>
<body class="h-screen overflow-hidden bg-base-100">
    <!-- MCP control indicator border (shown when app is remotely controlled) -->
    <div id="mcp-border" class="hidden" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; z-index: 9999; border: 8px solid rgba(239, 68, 68, 0.5);"></div>

    <!-- Elm application mount point -->
    <div id="elm-app" class="h-full"></div>

    <!-- Load compiled Elm application -->
    <script src="dist/elm.js"></script>

    <!-- Initialize Elm app and wire up ports -->
    <script>
        // Sidebar width persistence
        const SIDEBAR_WIDTH_KEY = 'teaforge-sidebar-width';
        const RECENT_WS_URLS_KEY = 'teaforge-recent-ws-urls';

        function getSavedSidebarWidth() {
            const saved = localStorage.getItem(SIDEBAR_WIDTH_KEY);
            return saved ? parseInt(saved, 10) : 320;
        }

        function getRecentWsUrls() {
            try {
                const saved = localStorage.getItem(RECENT_WS_URLS_KEY);
                return saved ? JSON.parse(saved) : [];
            } catch (e) {
                return [];
            }
        }

        function saveRecentWsUrls(urls) {
            localStorage.setItem(RECENT_WS_URLS_KEY, JSON.stringify(urls.slice(0, 5)));
        }

        // Initialize the Elm application with saved sidebar width and recent WS URLs
        const app = Elm.Main.init({
            node: document.getElementById('elm-app'),
            flags: {
                sidebarWidth: getSavedSidebarWidth(),
                recentWsUrls: getRecentWsUrls()
            }
        });

        // WebSocket manager for handling connections
        const wsManager = {
            socket: null,
            lineNumber: 0,
            userInitiatedDisconnect: false,
            wasConnected: false,
            hadError: false,

            connect(url) {
                // Close any existing connection
                this.disconnect();
                this.lineNumber = 0;
                this.userInitiatedDisconnect = false;
                this.wasConnected = false;
                this.hadError = false;

                sendToElm({ type: 'wsConnecting' });

                try {
                    this.socket = new WebSocket(url);

                    this.socket.onopen = () => {
                        this.wasConnected = true;

                        // Save URL to recent list
                        const recentUrls = getRecentWsUrls();
                        const newUrls = [url, ...recentUrls.filter(u => u !== url)].slice(0, 5);
                        saveRecentWsUrls(newUrls);

                        sendToElm({ type: 'wsConnected' });
                    };

                    this.socket.onmessage = (event) => {
                        const line = event.data.trim();
                        if (!line) return;

                        this.lineNumber++;

                        try {
                            const entry = JSON.parse(line);
                            sendToElm({
                                type: 'entryReceived',
                                payload: {
                                    lineNumber: this.lineNumber,
                                    entry: entry
                                }
                            });
                        } catch (parseError) {
                            sendToElm({
                                type: 'entryReceived',
                                payload: {
                                    lineNumber: this.lineNumber,
                                    error: parseError.message,
                                    rawText: line
                                }
                            });
                        }
                    };

                    this.socket.onerror = (error) => {
                        // Mark that an error occurred - the actual error message
                        // will be sent in onclose for better context
                        this.hadError = true;
                    };

                    this.socket.onclose = (event) => {
                        // Don't report error if user initiated disconnect
                        if (this.userInitiatedDisconnect) {
                            sendToElm({ type: 'wsDisconnected' });
                        } else if (event.wasClean) {
                            sendToElm({ type: 'wsDisconnected' });
                        } else {
                            // Send appropriate status based on connection state
                            if (!this.wasConnected) {
                                // Never connected = server not reachable
                                sendToElm({ type: 'wsConnectionFailed' });
                            } else {
                                // Was connected but lost connection
                                sendToElm({ type: 'wsConnectionLost' });
                            }
                        }
                        this.socket = null;
                    };
                } catch (error) {
                    sendToElm({
                        type: 'wsError',
                        payload: { error: error.message || 'Failed to create WebSocket connection' }
                    });
                }
            },

            disconnect() {
                if (this.socket) {
                    this.userInitiatedDisconnect = true;
                    this.socket.close();
                    this.socket = null;
                }
            }
        };

        // Wire up Elm outgoing port to Electron APIs
        // The Elm app sends commands via the outgoing port, and we handle them here
        if (app.ports && app.ports.outgoing) {
            app.ports.outgoing.subscribe(async function(message) {
                const { type, payload } = message;

                try {
                    switch (type) {
                        case 'openFileDialog':
                            const dialogResult = await window.electron.openFileDialog();
                            if (dialogResult.success && !dialogResult.canceled && dialogResult.filePath) {
                                // Immediately open the file for streaming
                                sendToElm({
                                    type: 'openInput',
                                    payload: { path: dialogResult.filePath }
                                });
                            } else if (!dialogResult.success) {
                                sendToElm({
                                    type: 'inputError',
                                    payload: { error: dialogResult.error || 'Failed to open file dialog' }
                                });
                            }
                            // If canceled, do nothing
                            break;

                        case 'openInput':
                            const openResult = await window.electron.openInput(payload.path);
                            sendToElm({
                                type: 'inputOpened',
                                payload: openResult
                            });
                            break;

                        case 'closeInput':
                            await window.electron.closeInput();
                            break;

                        case 'scrollIntoView':
                            // Scroll the specified element into view (only if needed)
                            const scrollElement = document.getElementById(payload.elementId);
                            if (scrollElement) {
                                scrollElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                            }
                            break;

                        case 'focusElement':
                            // Focus the specified element by ID
                            const focusEl = document.getElementById(payload.elementId);
                            if (focusEl) {
                                focusEl.focus();
                            }
                            break;

                        case 'saveSidebarWidth':
                            // Save sidebar width to localStorage
                            localStorage.setItem(SIDEBAR_WIDTH_KEY, payload.width.toString());
                            break;

                        case 'connectWebSocket':
                            wsManager.connect(payload.url);
                            break;

                        case 'disconnectWebSocket':
                            wsManager.disconnect();
                            // wsDisconnected will be sent by the onclose handler
                            break;

                        default:
                            console.warn('Unknown port message type:', type);
                    }
                } catch (error) {
                    console.error('Error handling port message:', error);
                    sendToElm({
                        type: 'inputError',
                        payload: {
                            error: error.message
                        }
                    });
                }
            });
        }

        // Helper function to send messages to Elm via the incoming port
        function sendToElm(message) {
            if (app.ports && app.ports.incoming) {
                app.ports.incoming.send(message);
            }
        }

        // Expose for E2E testing
        window.app = app;
        window.sendToElm = sendToElm;

        // Listen for entry-received events (streaming log entries)
        if (window.electron.onEntryReceived) {
            window.electron.onEntryReceived((data) => {
                sendToElm({
                    type: 'entryReceived',
                    payload: data
                });
            });
        }

        // Listen for input-error events
        if (window.electron.onInputError) {
            window.electron.onInputError((data) => {
                sendToElm({
                    type: 'inputError',
                    payload: data
                });
            });
        }

        // Listen for input-closed events
        if (window.electron.onInputClosed) {
            window.electron.onInputClosed((data) => {
                sendToElm({
                    type: 'inputClosed',
                    payload: data
                });
            });
        }

        // Listen for files selected via the File menu (Cmd+O)
        if (window.electron.onFileSelected) {
            window.electron.onFileSelected((data) => {
                // Trigger opening the file for streaming
                sendToElm({
                    type: 'openInput',
                    payload: { path: data.filePath }
                });
            });
        }

        // Show MCP control indicator if app was launched via MCP
        if (window.electron.isMcpControlled) {
            window.electron.isMcpControlled().then((isControlled) => {
                if (isControlled) {
                    document.getElementById('mcp-border').classList.remove('hidden');
                }
            });
        }
    </script>
</body>
</html>
